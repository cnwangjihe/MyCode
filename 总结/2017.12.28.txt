一道大水题：【UOJ142】万圣节的南瓜灯 

   简单来说就是给一个方格图，四周相邻的点联通，删掉一些点，问这是不是一棵树。
思路很简单，并查集，如果建出来的图没有环且只有一个联通快，则Yes。
然而，数据范围有点变态，n,m<=10^9 !!再看一下K，10^5，也就是说肯定有情况是不用跑并查集的。
首先可以知道，树的特征是边比点少一，由此可以推得一条不等式：
::n*m-K(cnt of point)>2n*m-m-4K(cnt of edge)
:::n*m<3K+m
所以只要n*m>400000就绝对是NO，否则跑一遍并查集。
于是它成了一道水题。
时间复杂度：O(min(nm,400000))
错误：1.看错题（不知第几次了），没看到每行第n个与第1个相连。
      2.没读完一组数据就读下一组（针对n*m<3K+m，然后一直没发现（小数据没问题，大数据查不了））。

一道听评讲后才会写的题：【SMOJ2371】 Symmetric Projections 

有一个n个点组成可重点集，求出有多少条过原点的直线能使它们这条直线上的投影能够对称。
某个点集是对称的，意味着存在一个中心点P，使得点集中所有不是P的点，
都有另外一个点和它唯一对应，使得这两个点连线的中点为P。
计算几何。
首先明确“不同直线”，设纸纤维y=kx+b，显然b没有用（两点确定一条直线），
然后平移对投影没有影响。所以把这些直线都平移到点P上。
由于投影构成的可重点集的对称中心P必为这n个点的中心在直线上的投影，
所以应该如何枚举直线呢，首先因为每个点都需要有一个对称点（除了投影与重心重叠的情况），
所以先随便定一个点，再枚举一个点，强制使他们为对称点，然后求出这条能使它们两个对称的并且经过P点的直线（几何问题，详见\pic\2017.12.28.1.png）。
剩下的问题就是怎样判断剩下的点是否合法，这时候向量就很有用了。
随便选的点为A，枚举的点为B，判断的点为C，计算CA与CB（假装是黑体）的叉积（|a||b|sin || x1y2-x2y1）,再除以|AB|就可以算出C到AB的距离（即为C的投影到P的投影的距离），由于是叉积（带符号），P点投影不同侧的点求出来的结果应该是互为相反数的，又因为每个C点都要除以一个|AB|所以可以忽略不除，
综上，求出每一个CA与CB的叉积，排一个序，判一下是否都有各自的相反数存在（注意去掉投影与P点重合的点）。
时间复杂度：O(n^2logn)

Pair用法：
没什么用，省一个结构体。
定义： pair<first,second> (first,second) //（构造函数）
make_pair(first,second)  //返回一个pair类型
 < , > , == //双关键字，先first后second
.first , .second //取值赋值

Map用法：
map，顾名思义，一对一的图，说白了就是一棵内置平衡树。
定义： map<first,second>
       map<first1, string>::iterator //迭代器（实质是指针）,可使用+1 || ++。
按first排序（如STL一贯的使用<,记得重载），值为second。
冉ê数：
    .insert(pair<first,second>(first,second)) //插入一个pair
    .insert(first,second) // 以键值为first插入一个值second
    //notice：上面两种方法必须保证键值first没有对应任何的值（即被erase或没有使用过），否则失败。
      insert有返回值，类型为pair，first为迭代器，
    [first]=second // 可以插入亦可修改 （即覆盖）
    .begin()  .end() // 返回头尾迭代器
    .rbegin() .rend()// 返回头尾反迭代器