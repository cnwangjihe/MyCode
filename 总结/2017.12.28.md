### 一道大水题：【UOJ142】万圣节的南瓜灯 ###

   简单来说就是给一个方格图，四周相邻的点联通，删掉一些点，问这是不是一棵树。

思路很简单，并查集，如果建出来的图没有环且只有一个联通快，则Yes。

然而，数据范围有点变态，n,m<=10^9 

!!再看一下K，10^5，也就是说肯定有情况是不用跑并查集的。

首先可以知道，树的特征是边比点少一，由此可以推得一条不等式：

::n\*m-K(cnt of point)\>2n\*m-m-4K(cnt of edge)

:::n\*m<3K+m

所以只要n\*m\>400000就绝对是NO，否则跑一遍并查集。

于是它成了一道水题。

时间复杂度：O(min(nm,400000))

错误：

      1.看错题（不知第几次了），没看到每行第n个与第1个相连。
 
      2.没读完一组数据就读下一组（针对n\*m<3K+m，然后一直没发现（小数据没问题，大数据查不了））。

### 一道听评讲后才会写的题：【SMOJ2371】 Symmetric Projections ###

有一个n个点组成可重点集，求出有多少条过原点的直线能使它们这条直线上的投影能够对称。

某个点集是对称的，意味着存在一个中心点P，使得点集中所有不是P的点，

都有另外一个点和它唯一对应，使得这两个点连线的中点为P。

计算几何。

首先明确“不同直线”，设纸纤维y=kx+b，显然b没有用（两点确定一条直线），

然后平移对投影没有影响。所以把这些直线都平移到点P上。

由于投影构成的可重点集的对称中心P必为这n个点的中心在直线上的投影，

所以应该如何枚举直线呢，首先因为每个点都需要有一个对称点（除了投影与重心重叠的情况），

所以先随便定一个点，再枚举一个点，强制使他们为对称点，

然后求出这条能使它们两个对称的并且经过P点的直线

（几何问题）。

![pic](https://github.com/cnwangjihe/MyCode/blob/master/%E6%80%BB%E7%BB%93/pic/2017.12.28.1.png)

剩下的问题就是怎样判断剩下的点是否合法，这时候向量就很有用了。

随便选的点为A，枚举的点为B，判断的点为C，计算CA与CB（假装是黑体）的叉积（|a||b|sin || x1y2-x2y1）,再除以|AB|就可以算出C到AB的距离（即为C的投影到P的投影的距离），由于是叉积（带符号），P点投影不同侧的点求出来的结果应该是互为相反数的，又因为每个C点都要除以一个|AB|所以可以忽略不除，

综上，求出每一个CA与CB的叉积，排一个序，判一下是否都有各自的相反数存在（注意去掉投影与P点重合的点）。

时间复杂度：O(n^2logn)

### Pair用法： ###

没什么用，省一个结构体。

定义： 

      pair<first,second> (first,second) //（构造函数）

      make_pair(first,second)  //返回一个pair类型

      < , > , == //双关键字，先first后second

      .first , .second //取值赋值

### Map用法： ###

map，顾名思义，一对一的图，说白了就是一棵内置平衡树。

定义： 
      
       map<first,second>

       map<first1, string>::iterator //迭代器（实质是指针）,*可使用++，但不可+=*。

*按first排序（如STL一贯的使用<,记得重载），值为second。*

內建函数：
 
    .insert(pair<first,second>(first,second)) //插入一个pair
 
    .insert(first,second) // 以键值为first插入一个值second
 
    //notice：上面两种方法必须保证键值first没有对应任何的值（即被erase或没有使用过），否则失败。
 
      insert有返回值，类型为pair，first为迭代器，
 
    [first]=second // 可以插入亦可修改 （即覆盖）
 
    .begin()  .end() // 返回头尾迭代器

    .rbegin() .rend()// 返回头尾反迭代器
